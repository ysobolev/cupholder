// Generated by CoffeeScript 1.6.2
(function() {
  var Client, WebSocket, crypto, events, promise, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  WebSocket = require("ws");

  uuid = require("node-uuid");

  events = require("events");

  promise = require("node-promise");

  crypto = require("cryptojs").Crypto;

  Client = (function(_super) {
    __extends(Client, _super);

    Client.prototype.TYPE_ID_WELCOME = 0;

    Client.prototype.TYPE_ID_PREFIX = 1;

    Client.prototype.TYPE_ID_CALL = 2;

    Client.prototype.TYPE_ID_CALLRESULT = 3;

    Client.prototype.TYPE_ID_CALLERROR = 4;

    Client.prototype.TYPE_ID_SUBSCRIBE = 5;

    Client.prototype.TYPE_ID_UNSUBSCRIBE = 6;

    Client.prototype.TYPE_ID_PUBLISH = 7;

    Client.prototype.TYPE_ID_EVENT = 8;

    Client.prototype.URI_WAMP_PROCEDURE = "http://api.wamp.ws/procedure#";

    function Client(uri, debug, closeOnError) {
      this.uri = uri;
      this.debug = debug != null ? debug : false;
      this.closeOnError = closeOnError != null ? closeOnError : false;
      this.authenticate = __bind(this.authenticate, this);
      this.handleAuth = __bind(this.handleAuth, this);
      this.publish = __bind(this.publish, this);
      this.unsubscribe = __bind(this.unsubscribe, this);
      this.subscribe = __bind(this.subscribe, this);
      this.call = __bind(this.call, this);
      this.prefix = __bind(this.prefix, this);
      this.onError = __bind(this.onError, this);
      this.onClose = __bind(this.onClose, this);
      this.close = __bind(this.close, this);
      this.send = __bind(this.send, this);
      this.onMessage = __bind(this.onMessage, this);
      this.state = "wait";
      this.calls = {};
      this.socket = new WebSocket(this.uri, {
        protocol: "wamp"
      });
      this.socket.on("error", this.onError);
      this.socket.on("message", this.onMessage);
      this.socket.on("close", this.onClose);
    }

    Client.prototype.onMessage = function(m, flags) {
      var deferred, desc, details, e, event, id, result, tokens, type, uri;

      if (flags.binary != null) {
        return this.error("Protocol error: received binary data.");
      }
      if (this.debug) {
        console.log("WAMP RX: ", m);
      }
      if (this.state === "closed") {
        return;
      }
      try {
        tokens = JSON.parse(m);
      } catch (_error) {
        e = _error;
        return this.error("Protocol error: received malformed JSON data.");
      }
      if (!Array.isArray(tokens)) {
        return this.error("Procotol error: received data is not an array.");
      }
      if (tokens.length === 0) {
        return this.error("Protocol error: received array is empty.");
      }
      if (this.state !== "open") {
        if (tokens[0] !== this.TYPE_ID_WELCOME) {
          return this.error("Procotol error: did not receive a welcome.");
        }
        if (tokens.length !== 4) {
          return this.error("Procotol error: malformed welcome message.");
        }
        type = tokens[0], this.sessionId = tokens[1], this.protocolVersion = tokens[2], this.serverIdent = tokens[3];
        this.state = "open";
        return this.emit("open");
      }
      switch (tokens[0]) {
        case this.TYPE_ID_CALLRESULT:
          if (tokens.length !== 3) {
            return this.error("Protocol error: malformed result.");
          }
          type = tokens[0], id = tokens[1], result = tokens[2];
          deferred = this.calls[id];
          delete this.calls[id];
          return deferred.resolve(result);
        case this.TYPE_ID_CALLERROR:
          if (tokens.length < 4) {
            return this.error("Protocol error: malformed error.");
          }
          type = tokens[0], id = tokens[1], uri = tokens[2], desc = tokens[3], details = tokens[4];
          deferred = this.calls[id];
          delete this.calls[id];
          return deferred.reject([uri, desc, details]);
        case this.TYPE_ID_EVENT:
          if (tokens.length !== 3) {
            return this.error("Protocol error: malformed event.");
          }
          type = tokens[0], uri = tokens[1], event = tokens[2];
          return this.emit("event", uri, event);
        default:
          return this.error("Procotol error: unrecognized message type.");
      }
    };

    Client.prototype.send = function(m) {
      var wire;

      wire = JSON.stringify(m);
      if (this.debug) {
        console.log("WAMP TX: ", wire);
      }
      return this.socket.send(wire, this.error);
    };

    Client.prototype.close = function() {
      return this.socket.close();
    };

    Client.error = function(e) {
      return Client.onError(e);
    };

    Client.prototype.onClose = function() {
      this.state = "closed";
      return this.emit("close");
    };

    Client.prototype.onError = function(e) {
      if (e == null) {
        return;
      }
      if (this.closeOnError) {
        this.socket.close();
      }
      return this.emit("error", e);
    };

    Client.prototype.prefix = function(prefix, uri) {
      return this.send([this.TYPE_ID_PREFIX, prefix, uri]);
    };

    Client.prototype.call = function() {
      var args, id, uri;

      uri = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      id = uuid.v1();
      this.send([this.TYPE_ID_CALL, id, uri].concat(__slice.call(args)));
      this.calls[id] = promise.defer();
      return this.calls[id].promise;
    };

    Client.prototype.subscribe = function(uri) {
      return this.send([this.TYPE_ID_SUBSCRIBE, uri]);
    };

    Client.prototype.unsubscribe = function(uri) {
      return this.send([this.TYPE_ID_UNSUBSCRIBE, uri]);
    };

    Client.prototype.publish = function(uri, event, exclude, eligible) {
      if (event == null) {
        event = null;
      }
      if (exclude == null) {
        exclude = null;
      }
      if (eligible == null) {
        eligible = null;
      }
      if (eligible != null) {
        exclude = exclude || [];
        return this.send([this.TYPE_ID_PUBLISH, uri, event, exclude, eligible]);
      } else if (exclude != null) {
        return this.send([this.TYPE_ID_PUBLISH, uri, event, exclude]);
      } else {
        return this.send([this.TYPE_ID_PUBLISH, uri, event]);
      }
    };

    Client.prototype.deriveKey = function(secret, extra, callback) {
      var iterations, keylen, salt;

      if (extra != null ? extra.salt : void 0) {
        salt = extra.salt;
        iterations = extra.iterations || 10000;
        keylen = extra.keylen || 32;
        secret = crypto.PBKDF2(secret, salt, keylen, {
          iterations: iterations,
          hasher: crypto.SHA256,
          asBytes: true
        });
        return Buffer(secret).toString("base64");
      } else {
        return secret;
      }
    };

    Client.prototype.handleAuth = function(challenge, authSecret, d) {
      var challenge_obj, hmac, reply, sig;

      challenge_obj = JSON.parse(challenge);
      authSecret = this.deriveKey(authSecret, challenge_obj.authextra);
      hmac = crypto.HMAC(crypto.SHA256, challenge, authSecret, {
        asBytes: true
      });
      sig = Buffer(hmac).toString("base64");
      reply = this.call(this.URI_WAMP_PROCEDURE + "auth", sig);
      return promise.when(reply, d.resolve, d.reject);
    };

    Client.prototype.authenticate = function(authKey, authSecret, authExtra) {
      var d, reply,
        _this = this;

      if (authExtra == null) {
        authExtra = null;
      }
      d = promise.defer();
      reply = this.call(this.URI_WAMP_PROCEDURE + "authreq", authKey, authExtra);
      reply.addCallback(function(challenge) {
        return _this.handleAuth(challenge, authSecret, d);
      });
      reply.addErrback(this.error);
      return d.promise;
    };

    return Client;

  }).call(this, events.EventEmitter);

  module.exports = {
    Client: Client
  };

}).call(this);
